from search import Problem

# Standardized Templated Design generated by Copilot
# Group Members: Kevin Nguyen, Joshua Duncan
# Last updated March 4, 2024


class WolfGoatCabbage(Problem):
    def __init__(self, initial, goal):
        """Define initial and goal states"""
        super().__init__(initial, goal)

    def goal_test(self, state):
        """Check if the current state is the goal state"""
        return state == self.goal

    def result(self, state, action):
        """Given a state and an action, return the new state"""
        new_state = set(state) ^ set(action)
        return new_state

    def actions(self, state):
        """Return possible actions in a given state"""
        actions = []
        farmer_location = "F"  # The farmer must be included in all actions
        other_objects = set(state) - {"F"}

        # If the farmer is on the left bank, actions move objects from left to right, and vice versa
        if "F" in state:
            for obj1 in other_objects:
                for obj2 in other_objects:
                    if obj1 != obj2:
                        actions.append({farmer_location, obj1, obj2})
        else:
            for obj1 in other_objects:
                actions.append({farmer_location, obj1})
        return actions


# Test Example usage:
initial_state = {"F", "G", "W", "C"}
goal_state = {"G", "W", "C", "F"}
problem = WolfGoatCabbage(initial_state, goal_state)
print(problem.actions(initial_state))
print(problem.result(initial_state, {"F", "G"}))
print(problem.result(problem.result(initial_state, {"F", "G"}), {"F"}))
