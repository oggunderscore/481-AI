from search import *
import time

# Standardized Templated Design generated by Copilot
# Group Members: Kevin Nguyen, Joshua Duncan, Noah Khayat Albirkdar

# Last updated March 6, 2024


class WolfGoatCabbage(Problem):
    def __init__(self, initial=None, goal=None):
        """Define initial and goal states"""
        if initial is None:
            initial = frozenset({"F", "G", "W", "C"})
        if goal is None:
            goal = frozenset({})
        super().__init__(initial, goal)

    def goal_test(self, state):
        """Check if the current state is the goal state"""
        return state == self.goal

    def result(self, state, action):
        """Given a state and an action, return the new state"""
        new_state = set(state) ^ set(action)
        return frozenset(new_state)

    def actions(self, state):
        """Return possible actions in a given state"""
        available_actions = []
        farmer_location = "F"
        other_objects = set({"G", "W", "C"})

        list = []
        for item in state:
            if not item == "F":
                list.append(item)
        newState = frozenset(list)

        if "F" in state:
            # Farmer is on the left bank, options to move objects from left to right

            # print(f"NewState: {newState}")
            for obj in newState:
                if not (obj == "W" and "G" in newState and "C" in newState):
                    # print(f"Adding: {frozenset({farmer_location, obj})}")
                    available_actions.append(frozenset({farmer_location, obj}))

        else:
            # Farmer is on the right bank, options to move objects from right to left
            for obj in other_objects - state:
                # print(f"Obj: {obj}")
                available_actions.append(frozenset({farmer_location, obj}))
            if not frozenset({"W"}) == newState:
                available_actions.append(frozenset({farmer_location}))

        # Filter out actions where the goat and the wolf or the goat and the cabbage are left alone
        # print(f"available_actions: {available_actions}")

        for action in available_actions:
            # if (
            #     ("G" in action and "W" in action)
            #     or ("G" in action and "C" in action)
            #     or ("F" == action)
            # ):
            #     available_actions.remove(action)
            # print("check")
            # print(f"Action: {action}")

            # time.sleep(1)
            # print(f"if F == action: {frozenset({'F'}) == action}")
            if frozenset({"F"}) == action:
                something = "F" in state
                # print(f"Checking | RESULT: {something}\n")
                if "F" in state:
                    # print("Detected F in action")
                    available_actions.remove(action)
                elif frozenset({"W"}) == state:
                    available_actions.remove(action)
                elif frozenset({"C"}) == state:
                    available_actions.remove(action)
            # print(f"if f in action: {'F' in action} | if c in action: {'C' in action}")
            if "F" in action and "C" in action:
                # print(f"F and C is action")
                if "W" in state and "G" in state:
                    # print(f"W and G are in state")
                    available_actions.remove(action)
                # if not ("G" in state and "W" in state):
                #     available_actions.remove(action)
            if "F" in action and "W" in action:
                if frozenset({"W", "C"}) == state or frozenset({"C", "W"}) == state:
                    available_actions.remove(action)
        # print(f"new available_actions: {available_actions}")
        return available_actions


# Test Example usage:
initial_state = {"F", "G", "W", "C"}
# goal_state = {"G", "W", "C", "F"}
wgc = WolfGoatCabbage()
# print(wgc.actions(initial_state))
# state_1 = wgc.result(initial_state, {"F", "G"})
# print(state_1)
# # print(wgc.result(wgc.result(initial_state, {"F", "G"}), {"F"}))
# state_2 = wgc.result(state_1, {"F"})
# print(state_2)

# state_3 = wgc.result(state_2, {"F", "C"})
# print(state_3)
# state_4 = wgc.result(state_3, {"F", "G"})
# print(state_4)
# state_5 = wgc.result(state_4, {"F", "W"})
# print(state_5)
# state_6 = wgc.result(state_5, "F")
# print(state_6)
# state_7 = wgc.result(state_6, {"F", "G"})
# print(state_7)
# print(wgc.goal_test({}))

if __name__ == "__main__":
    wgc = WolfGoatCabbage()
    # solution() is a function in class node that returns the sequence of actions
    solution = depth_first_graph_search(wgc).solution()
    print(solution)
    # solution = breadth_first_graph_search(wgc).solution()
    # print(solution)

# This needs to be fixed somehow...
# print(depth_first_graph_search(wgc).solution())
